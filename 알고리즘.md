# 알고리즘

<br>

#### 재귀 vs 반복

|                |                  재귀                   |          반복          |
| :------------: | :-------------------------------------: | :--------------------: |
|      종료      | 재귀 함수 호출이 종료되는 베이스 케이스 |   반복문의 종료 조건   |
|   수행 시간    |              (상대적) 느림              |          빠름          |
|  메모리 공간   |           (상대적) 많이 사용            |       적게 사용        |
| 소스 코드 형태 |          선택 구조 (if, else)           | 반복 구조 (for, while) |
|  무한 반복시   |             스택 오버플로우             |  CPU를 반복해서 점유   |

<br>

#### 정렬

|            | 최선        | 평균        | 최악        |
| ---------- | ----------- | ----------- | ----------- |
| 삽입정렬   | n           | $$ n^2 $$   | $$ n^2 $$   |
| 선택정렬   | $$ n^2 $$   | $$ n^2 $$   | $$ n^2 $$   |
| 버블정렬   | $$ n^2 $$   | $$ n^2 $$   | $$ n^2 $$   |
| 퀵정렬     | $$ nlogn $$ | $$ nlogn $$ | $$ n^2 $$   |
| 힙정렬     | $$ nlogn $$ | $$ nlogn $$ | $$ nlogn $$ |
| 병합정렬   | $$ nlogn $$ | $$ nlogn $$ | $$ nlogn $$ |
| 카운팅정렬 | n+k         | n+k         | n+k         |

- 삽입정렬

  - 선택법
  - 추가 메모리 없다
  - 안정 정렬

  -   데이터가 정렬되어 있다고 가정하고 지금 현재 값을 해당 위치에 삽입하여 정렬하는 방법이다.

      오름차순으로 정렬할때 2번째 인덱스부터 앞의 정렬된 구간과 비교하여 해다하는 위치에 삽입하는 것이다.

  - ```
    public class InsertionSort {
    
    	public static void main(String[] args) {
    		int[] arr = { 15, 3, 29, 32, 13, 17, 19, 22 };
    
    		for (int i = 1; i < arr.length; i++) {
    			int target = arr[i]; // 삽입해야할 원소
    			int idx = i - 1; // 정렬된 구간중 비교할 위치
    
    			// 정렬된 구간 오른쪽에서부터 왼쪽으로 한칸씩 비교하며
    			// 타겟보다 클 경우 한칸씩 오른쪽으로
    			while (idx >= 0 && target < arr[idx]) {
    				arr[idx + 1] = arr[idx];
    				idx--;
    			}
    			arr[idx + 1] = target;
    			System.out.println(target + " : " + Arrays.toString(arr));
    		}
    	}
    
    }
    ```

- 선택정렬

  - 교환법

  - 추가 메모리 없다

  - 안정 정렬

  - 정렬되지 않은 구간에서 최소 값을 찾아 맨 앞에 위치한 값과 바꾼다. 

  - ```
    
    ```

  - 