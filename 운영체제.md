# 운영체제

<br>

#### 프로세스 vs 스레드

  프로세스는 실행되고 있는 하나의 프로그램이고, 스레드는 프로세스안에서 처리하고 있는 하나의 작업단위이다. 프로세스는 독립된 자원을 할당 받아 사용하고, 스레드는 프로세스 안에서 자원을 공유하면서 실행한다. 스레드는 프로세스의 code, data, heap을 공유하고 stack만 별도로 가진다.

  자원을 공유하기에 멀티 스레드가 조금 더 효율 적이고 컨텍스트 스위칭 비용이 적어진다. 동기화 문제를 해결하기 어렵다.

<br>

#### 메모리 구조

- Code 영역 : 프로그램 코드들, 실행 명령을 포함하는 메모리이거나 목적 파일에 있는 프로그램 영역

- Data 영역 : 전역 변수들(static), 프로그램 실행 시 할당되며, 종료시 소멸, 프로그램의 가상 주소 공간

- Heap 영역 : 사용자의 동적할당, 자바의 경우 모든 객체가 힙 영역에 존재, 코드 영역과는 별도로 유지되는 자유 영역

- Stack 영역 : 지역 변수, 매개 변수 등 함수 호출 시 할당되며, 함수 완료되면 소멸, 데이터를 일시적으로 저장하는 영역

   code 에서 stack 영역으로 갈수록 물리적인 주소가 높다

  <br>

##### fork() & exec

- fork : 자신의 프로세스와 똑 같은 프로세스를 copy-on-write 형식으로 실행하게 되며, 이때 생성된 프로세스틑 자신만의 PID를 가지고 독자적인 길을 가게된다.

- exec : 다른 프로세스를 만들 수 있다. 새로운 프로세스가 생기는 것이 아니다. 호출한 프로세스가 다른 프로세스가 되는 것이다.

<br>

##### 컨텍스트 스위칭(Context switching)

 하나의 프로세스가 cpu를 사용중인 상태에서 다른 프로세스가 cpu를 사용하도록 하기 위해 이전 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업

<br>

##### 메모리 할당 알고리즘

First Fit : 충분한 공간이 발견되면 바로 할당

Next Fit: First Fit과 유사한데, 시작할 인덱스가 저번에 참조한 공간

Best Fit : 전체 중 가장 최적인 공간, 이론적으로 가장 느리다.

 <br>

##### 메모리 단편화

메모리의 빈공간 또는 자료가 여러 개의 조각으로 나뉘는 현상, 빈공간의 크기보다 큰 메모리는 사용 할 수 없게 된다.

- 내부 단편화 : 분할된 영역이 할당된 프로그램의 크기보다 커서 사용되지 않고 남아 있는 빈 공간

- 외부 단편화 : 분할된 영역이 할당될 프로그램의 크기보다 작아서 할당할 수 없어 모두 빈공간으로 남아 있는 전체 영역

해결 방법 : 메모리 압축, 메모리 통합, 세그멘테이션, 페이징

 <br>

##### 세그멘테이션

  가상기억장치(가상메모리)를 서로 크기가 다른 논리적 단위인 세그먼트로 분할하고 메모리를 할당하며 주소변환을 하는 기법, 세그먼트들의 크기가 서로 다르기 때문에 메모리를 페이징 기법에서처럼 미리 크기를 잡아 둘 수 없고, 메모리에 적재될 때 빈공간을 찾아 할당하는 사용자 관점의 가상 메모리 기법. 내부단편화는 없지만 외부단편화가 발생한다.

 <br>

##### 페이징

 가상기억장치(가상메로리)를 모두 같은 크기의 블록으로 편성하고 이 일정한 크기인 블록을 페이지라고 한다. 주소공간을 페이지단위로 나누고 실제 기억공간(ram)은 페이지 크기와 같은 크기의 블록을 프레임으로 나누어 사용한다. 그리하여 사용하는 메모리는 프레임에 올리고 사용하지 않는 메모리는 페이지에 저장한다. 필요한 메모리는 페이지 단위로 프레임에 올리고 사용하지 않는 프레임은 페이지로 옮기는 기법인다. 외부단편화는 해결하지만 내부단편화가 발생한다.

<br>

##### 스케줄링

여러 프로세스가 번갈아 사용하는 자원을 어떤 시점에 어떤 프로세스에 할당할지 결정하는 것

- Non-Preemtive (비선점) : 이미 할당된 자원을 다른 프로세스가 뺏을 수 없음. 
  - FCFS : 큐에 도착한 순서대로 CPU 자원 할당.
  - SJF : 실행시간이 가장 짧은 JOB 먼저 자원 할당.
  - HRN : (대기시간 + 서비스시간 / 서비스시간)으로 우선순위를 매겨 Higst Responseratio 순으로 자원 할당.
  - Priority Queue : 우선순위를 부여하여 높은 프로세스에게 먼저 자원 할당.

- Preemptive (선점) : 우선순위가 높은 프로세스가 언제든지 자원을 뺏을 수 있음.
  - SRT(Shotest Remaining Time) : 비선점 SJF를 선점 형태로 변형함.
  - RR : 시분할 시스템. 할당시간이 클수록 FCFS와 비슷하지만 짧으면 콘텍스트 스위칭과 오버헤드가 많이 발생
  - 다단계 큐 : 프로세스를 특정그룹으로 분류 할 수 있으면 준비상태 큐를 사용함.
  - 다단계 피드백 큐 : 다단계큐에서 그룹이 준비상태에 들어가면 큐 사이를 이동할 수 없는데, 그것을 이동 할 수 있게 하는 기법(time out 나면 이동함)

<br>

##### 임계영역

 여러 개의 프로세스가 공유하는 데이터 및 자원에 대해 어느 한 시점에서 하나의 프로세스만 자원 또는 데이터를 사용하도록 지정된 공유 공간, 특정 프로세스가 독점 불가능

<br>

##### 세마포어

여러 프로세스나 쓰레드가 공유자원에 접근하는 것을 제어하기 위한 방법, 즉 병행 처리를 위한 프로세스 동기화 기법

semWait 연산 : 세마포어 값을 감소시킨다 만일 값이 음수가 되면 semWait를 호출한 프로세스는 블록된다. 음수가 아니면 프로세스는 계속 수행될 수 있다.

semSignal 연산 : 세마포어 값을 증가시킨다. 만약 값이 양수가 아니면(0이거나 음수), semWait 연산에 의해 블록된 프로세스들을 깨운다.

카운팅(범용)세마포어 : 초기값이 0이상의 수

 <br>

##### 세마포어 vs 뮤텍스

  둘 다 상호배제의 방법, 세마포어는 지정된 n개의 쓰레드만 접근 가능하지만 뮤텍스는 오직 하나의 쓰레드만 접근 가능하기 때문에 이진 세마포어라고도 불림

세마포어는 뮤텍스가 될 수 잇지만, 뮤텍스는 세마포어가 될 수 없다.

 <br>

##### 교착상태(Dead Lock)

  한정된 자원을 여러 곳에서 사용하려고 할때 발생, 스레드가 락이 풀릴 때까지 대기하고 있는 무한 대기 상태, 상호배제, 점유대기, 비 선점, 순환대기 4가지 조건을 만족해야 한다.

- 상호배제 : 프로세서들이 자원을 배타적 점유, 다른 프로세서들이 자원 사용 불가

- 점유와 대기 : 부분 할당, 다른 종류의 자원을 부가적으로 요구하면서, 이미 어떤 자원을 점유하고 잇음

- 비선점 : 자원들은 그들이 점유하고 잇는 프로세스로부터 도중에 해체되지 않음

- 환형대기 : 프로세스와 자원들이 원형을 이루며, 각 프로세스는 자신에게 할당된 자원을 가지면서, 상대방 프로세스의 자원을 상호요청 하는 경우

해결방법 : 예방, 회피, 발견, 복구

 <br>

##### 기아상태

  작업이 결코 사용할 수 없는 자원을 계속 기다리는 결과(교착상태)를 예방하려고 자원을 할당 할 때 발생(기다림)하는 효과